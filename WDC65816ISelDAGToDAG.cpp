//===- WDC65816ISelDAGToDAG.cpp - A dag to dag inst selector for WDC65816 -===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the WDC65816 target.
//
//===----------------------------------------------------------------------===//

#include "WDC65816TargetMachine.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
using namespace llvm;

//===----------------------------------------------------------------------===//
// Instruction Selector Implementation
//===----------------------------------------------------------------------===//

//===--------------------------------------------------------------------===//
/// WDC65816DAGToDAGISel - WDC65816 specific code to select WDC65816 machine
/// instructions for SelectionDAG operations.
///
namespace {
    class WDC65816DAGToDAGISel : public SelectionDAGISel {
    public:
        explicit WDC65816DAGToDAGISel(WDC65816TargetMachine &tm)
            : SelectionDAGISel(tm)
        {
        }
        
        void Select(SDNode *N) override;
        
        bool SelectAbs(SDValue N, SDValue &R1);
        bool SelectAbsLong(SDValue N, SDValue &R1);
        bool SelectDirectPage(SDValue N, SDValue &R1);
        
        StringRef getPassName() const override {
            return "WDC65816 DAG->DAG Pattern Instruction Selection";
        }
        
        // Include the pieces autogenerated from the target description.
#include "WDC65816GenDAGISel.inc"
        
    private:
        //SDNode* getGlobalBaseReg();
    };
}  // end anonymous namespace


#if 0
SDNode* WDC65816DAGToDAGISel::getGlobalBaseReg() {
    unsigned GlobalBaseReg = TM.getInstrInfo()->getGlobalBaseReg(MF);
    WDC_LOG("WDC_TODO - This method is probably implemented wrong...");
    return CurDAG->getRegister(GlobalBaseReg,
                               getTargetLowering()->getPointerTy()).getNode();
}
#endif


bool WDC65816DAGToDAGISel::SelectAbs(SDValue N, SDValue &R1) {
    WDC_LOG("WDC_TODO - Unimplemented method called");
    return false;
}


bool WDC65816DAGToDAGISel::SelectAbsLong(SDValue N, SDValue &R1) {
    WDC_LOG("WDC_TODO - Unimplemented method called");
    return false;
}


bool WDC65816DAGToDAGISel::SelectDirectPage(SDValue N, SDValue &R1) {
    WDC_LOG("WDC_TODO - Unimplemented method called");
    return false;
}


void WDC65816DAGToDAGISel::Select(SDNode *N) {
    SDLoc dl(N);
    if (N->isMachineOpcode()) {
        N->setNodeId(-1);
        return;             // Already selected.
    }
    
    WDC_LOG("WDC_TODO - Unimplemented method called, opcode=" << N->getOpcode());

#if 0 // WDC_TODO - Do we need any of this?
    // Uncomment the following line to see the node info.
    // N->dumprFull(CurDAG);
    switch (N->getOpcode()) {
        default: break;
            
        case SPISD::GLOBAL_BASE_REG:
            return getGlobalBaseReg();
            
        case ISD::SDIV:
        case ISD::UDIV: {
            // sdivx / udivx handle 64-bit divides.
            if (N->getValueType(0) == MVT::i64)
                break;
            // FIXME: should use a custom expander to expose the SRA to the dag.
            SDValue DivLHS = N->getOperand(0);
            SDValue DivRHS = N->getOperand(1);
            
            // Set the Y register to the high-part.
            SDValue TopPart;
            if (N->getOpcode() == ISD::SDIV) {
                TopPart = SDValue(CurDAG->getMachineNode(SP::SRAri, dl, MVT::i32, DivLHS,
                                                         CurDAG->getTargetConstant(31, MVT::i32)), 0);
            } else {
                TopPart = CurDAG->getRegister(SP::G0, MVT::i32);
            }
            TopPart = SDValue(CurDAG->getMachineNode(SP::WRYrr, dl, MVT::Glue, TopPart,
                                                     CurDAG->getRegister(SP::G0, MVT::i32)), 0);
            
            // FIXME: Handle div by immediate.
            unsigned Opcode = N->getOpcode() == ISD::SDIV ? SP::SDIVrr : SP::UDIVrr;
            return CurDAG->SelectNodeTo(N, Opcode, MVT::i32, DivLHS, DivRHS,
                                        TopPart);
        }
        case ISD::MULHU:
        case ISD::MULHS: {
            // FIXME: Handle mul by immediate.
            SDValue MulLHS = N->getOperand(0);
            SDValue MulRHS = N->getOperand(1);
            unsigned Opcode = N->getOpcode() == ISD::MULHU ? SP::UMULrr : SP::SMULrr;
            SDNode *Mul = CurDAG->getMachineNode(Opcode, dl, MVT::i32, MVT::Glue,
                                                 MulLHS, MulRHS);
            // The high part is in the Y register.
            return CurDAG->SelectNodeTo(N, SP::RDY, MVT::i32, SDValue(Mul, 1));
        }
    }
#endif
}


#if 0 // WDC_TODO - Not sure what this is about...
/// SelectInlineAsmMemoryOperand - Implement addressing mode selection for
/// inline asm expressions.
bool
SparcDAGToDAGISel::SelectInlineAsmMemoryOperand(const SDValue &Op,
                                                char ConstraintCode,
                                                std::vector<SDValue> &OutOps) {
    SDValue Op0, Op1;
    switch (ConstraintCode) {
        default: return true;
        case 'm':   // memory
            if (!SelectADDRrr(Op, Op0, Op1))
                SelectADDRri(Op, Op0, Op1);
            break;
    }
    
    OutOps.push_back(Op0);
    OutOps.push_back(Op1);
    return false;
}
#endif

/// createWDC65816ISelDag - This pass converts a legalized DAG into a
/// WDC65816-specific DAG, ready for instruction scheduling.
///
FunctionPass *llvm::createWDC65816ISelDag(WDC65816TargetMachine &TM) {
    return new WDC65816DAGToDAGISel(TM);
}
